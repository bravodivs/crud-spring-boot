
    /*
    public ResponseEntity<Object> exportHandler(HttpServletResponse response, String type) throws IOException {
        ResponseEntity<Object> responseEntity;
        switch (type.toLowerCase()) {
            case "csv" -> {
                responseEntity = exportCsv(response, productDtoList);
//                handle errors also
                logger.info("CSV file generated");
                //        this will delete when the server is shut down!!
                file.deleteOnExit();
            }
            case JSON -> {
                exportJson(response, productDtoList);
                responseEntity = new ResponseEntity<>(HttpStatus.OK);
                file.deleteOnExit();
                logger.info("JSON file generated");
            }
            case "pdf" -> {
                exportPdf(response, productDtoList);
                responseEntity = new ResponseEntity<>(HttpStatus.OK);
                file.deleteOnExit();
                logger.info("PDF file generated");
            }
            case "xml" -> {
                exportXml(response, productDtoList);
                responseEntity = new ResponseEntity<>(HttpStatus.OK);
                file.deleteOnExit();
                logger.info("XML file generated");
            }
            default -> throw new CustomException(String.format("File type %s not valid", type), HttpStatus.BAD_REQUEST);
        }
//TODO:        not able to delete coz file in use
//        if (Files.deleteIfExists(Path.of(file.getPath()))) {
//            logger.info("File deleted ");
//        }

        return responseEntity;
    }

     */
    public ResponseEntity<Object> exportCsv(HttpServletResponse response, List<ProductDto> productDtoList) throws IOException {

//        creating a file
//        fileObj.setFileExtension("csv");
        this.fileExtension = "csv";
        String filename = getExportFileName();
        file = new File(filename);
        if (file.createNewFile()) {
            logger.info("File created with name {}", filename);
        }

        /*
        response.setContentType("text/csv");
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION,
                "attachment; filename=\"" + filename + "\"");

//        : fix-> only first value of images being written
        try {
            ListStringMappingStrategy mappingStrategy = new ListStringMappingStrategy();
            mappingStrategy.setType(Product.class);
            StatefulBeanToCsv<Product> writer = new StatefulBeanToCsvBuilder<Product>(response.getWriter())
//                    .withMappingStrategy(mappingStrategy)
                    .withOrderedResults(true)
                    .build();
            writer.write(productList);
        } catch (Exception e) {
            e.printStackTrace();
        }

         */

        try {
//        writing to a file
            FileWriter outputFile = new FileWriter(file);
            CSVWriter writer = new CSVWriter(outputFile);
            //            write headers
            ArrayList<String> headers = new ArrayList<>();
            Field[] fields = Product.class.getDeclaredFields();

            for (Field field : fields) {
                headers.add(field.getName().toUpperCase());
            }
            writer.writeNext(headers.toArray(new String[0]));

//            write the data
            for (ProductDto productDto : productDtoList) {
                String[] data = {productDto.getId(),
                        productDto.getName(),
                        productDto.getDescription(),
                        String.valueOf(productDto.getQuantity()),
                        String.valueOf(productDto.getPrice()),
                        String.valueOf(productDto.getImages()),
                        String.valueOf(productDto.getCreatedAt()),
                        String.valueOf(productDto.getModifiedAt())};
                writer.writeNext(data);
            }
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

//        prepare response for downloading the file
        InputStreamResource resource = new InputStreamResource(new FileInputStream(file));
        HttpHeaders headers = new HttpHeaders();
        headers.add(CONTENT_DISPOSITION, String.format("attachment; filename=\"%s\"", file.getName()));
        headers.setContentType(MediaType.parseMediaType("text/csv"));

        return new ResponseEntity<>(resource, headers, HttpStatus.OK);
    }

/*
    public String exportJson(HttpServletResponse response, List<ProductDto> productList) {
        response.setContentType("text/json");
        response.setHeader("Content-Disposition", "attachment; filename=products.json");

        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
            objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
            return objectMapper.writeValueAsString(productList);
        } catch (Exception e) {
            return "Error converting to json";
        }
    }

 */

    public void exportPdf(HttpServletResponse response, List<ProductDto> productDtoList) throws IOException {
        /*
        fileObj.setFileExtension("pdf");
        String filePath = fileObj.getFileName();
        response.setContentType("application/pdf");
        response.setHeader("Content-Disposition", String.format("attachment; filename=%s", filePath));

        try (PDDocument document = new PDDocument()) {
            PDPage page = new PDPage();
            document.addPage(page);

            PDPageContentStream contentStream = new PDPageContentStream(document, page);
            contentStream.setFont(PDType1Font.HELVETICA_BOLD, 10);

            float margin = 50;
            float yStart = page.getMediaBox().getHeight() - margin;
            float tableWidth = page.getMediaBox().getWidth() - 2 * margin;
            float yPosition = yStart;
            int rows = productList.size();
            int cols = 8;
            float rowHeight = 20;
            float tableHeight = rowHeight * rows;
            float tableRowHeight = tableHeight / (float) rows;
            float tableWidthMargin = tableWidth / (float) cols;
            float cellMargin = tableWidthMargin / 5f;

            //  table headers
            drawTableHeader(contentStream, yPosition, tableWidth, tableRowHeight, cellMargin);

            //  table rows with product data
            yPosition -= tableRowHeight;
            for (Product product : productList) {
                drawTableRow(contentStream, yPosition, tableWidth, tableRowHeight, cellMargin, cols, product);
                yPosition -= tableRowHeight;
            }
//TODO: not auto downloading
            contentStream.close();
            document.save(filePath);
            logger.info("PDF created successfully");
        } catch (IOException e) {
            e.printStackTrace();
        }

         */

//        fileObj.setFileExtension("pdf");
        /*
        this.fileExtension = "pdf";
        String filename = getExportFileName();
        file = new File(filename);
        if (file.createNewFile()) {
            logger.info("File created with name {}", filename);
        }

        response.setContentType("application/pdf");
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, String.format("attachment; filename=\"%s\"", file.getName()));
        PdfExporter productPdfExporter = new PdfExporter(productDtoList);
        productPdfExporter.export(response);

         */
    }

    //    TODO: try to make it dynamic by having List<object>, classtype. then shift to util.
    public void exportXml(HttpServletResponse response, List<ProductDto> productDtoList) throws IOException {
        response.setContentType("application/xml");
        response.setHeader("Content-Disposition", "attachment; filename=products.xml");

        String filePath = "products.xml";
        try {
            JAXBContext context = JAXBContext.newInstance(ProductDtoListWrapper.class);
            Marshaller marshaller = context.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);

            ProductDtoListWrapper wrapper = new ProductDtoListWrapper();
            wrapper.setProductDtoList(productDtoList);
            marshaller.marshal(wrapper, new FileOutputStream(filePath));
            logger.info("XML created successfully");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
package com.example.demo.service;

import com.example.demo.model.ProductDto;
import com.example.demo.util.CsvExporterUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.io.File;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ProductExportServiceTest {
    @Mock
    InputStreamResource inputStreamResource;
    @TempDir
    File file;
    @InjectMocks
    private ProductExportService productExportService;
    private List<ProductDto> productDtoList;
    MockedStatic<CsvExporterUtil> mockedStatic = mockStatic(CsvExporterUtil.class);
    @BeforeEach
    void setUp(){
        List<String> images = List.of(
                "image1",
                "image2"
        );
        productDtoList= List.of(
                new ProductDto("Sample name 1", "Sample desc 1", 12, 2.0,images ),
                new ProductDto("Sample name 2", "Sample desc 2", 13, 33.0, images)
        );
        productExportService.setDateFormat("yyyy-mm-dd");
        productExportService.setDefaultFileNameTemplate("dummy-export");
    }
    @Test
    void testExportHandlerSuccess(@TempDir Path tempDir){
//        file = tempDir.resolve("test").toFile();
//        when(CsvExporterUtil.export(anyList(), anyString())).thenReturn(new File(file, "test.csv"));
//
//        ResponseEntity<Object> responseEntity = productExportService.exportHandler(productDtoList, "csv");
//
//        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
    }
}
package com.example.demo.util;

import com.example.demo.exception.CustomException;
import com.opencsv.CSVWriter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class CsvExporterUtilTest {
    @Mock
    CSVWriter csvWriter;
    private List<String[]> dataArray;
    @BeforeEach
    void setUp() {
        dataArray = new ArrayList<>();
        dataArray.add(new String[]{"header1", "header2"});
        dataArray.add(new String[]{"data1", "data2"});
    }

    @Test
    void testExportSuccess(@TempDir Path tempDir) {
//        TODO: try resource directory with static path.
//        File tempFile = tempDir.resolve("test.csv").toFile();
        File tempFile = new File("/resources");
//
//        File exportedFile = CsvExporterUtil.export(dataArray, tempFile.getAbsolutePath());
//
//        assertTrue(exportedFile.exists());
//        assertTrue(exportedFile.isFile(), "Exported file is not a regular file");
//        assertTrue(exportedFile.length() > 0, "File is empty");
    }
}